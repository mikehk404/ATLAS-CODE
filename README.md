# ATLAS_ASCEND 1.2 - Source Code & Implementation Guide
> **Team:** VN7-ATLAS  | **Event:** ASCEND 2026  | **Version:** 5 (Hybrid Ground-Satellite Architecture)

This repository contains the source code, machine learning pipeline, and hardware wiring schematics for the ATLAS_ASCEND disaster early warning ecosystem. For the full theoretical background and architecture design, please refer to our main **Technical Report**.

---

## Repository Structure

The project is divided into two main domains: Hardware Firmware (C++) and the AI Ground System (Python). 



### 1. Hardware Firmware (C++)
Source files for the microcontrollers operating at the edge and in orbit.
* `gns_code.cpp`: Firmware for the Ground Sensor Node (`ESP32-WROOM`). Handles sensor polling and LoRa transmission.
* `satellite_codev5_master.cpp`: Firmware for the CubeSat 1U Master Node (`ESP32-S3`). Handles telemetry, navigation, and LoRa relay.
* `satellite_codev5_slave.cpp`: Firmware for the CubeSat 1U Slave Node (`ESP32-CAM`). Handles image capture and chunking.

### 2. Processing System (Python)
Scripts for data simulation, model training, and the main GIS dashboard.
* `generate_history.py`: Generates synthetic historical sensor data and saves it to `history.csv` to build the initial baseline.
* `train_model.py`: Trains the Random Forest model using historical data and exports the compiled model as `rf_landslide.joblib`.
* `sim_nodes.py`: Simulates a CubeSat LoRa downlink pass, generating correctly formatted telemetry packets (`exc.txt`).
* `predict_inference.py`: The core inference engine. Loads the `.joblib` model to process incoming node data and outputs risk probabilities.
* **`AI_Ground_System.py`**: **[MAIN ENTRY POINT]** The primary application script. It parses incoming LoRa telemetry, imports `predict_inference.py` to calculate risk scores, and generates the interactive Folium/Cartopy GIS Dashboard.

---

## Getting Started (How to Run & Simulate)

### Phase 1: AI Simulation (Software-Only Test)
You can evaluate the machine learning pipeline and generate the dashboard locally without physical hardware.

**Prerequisites:** Python 3.9+
```bash
# 1. Navigate to your project folder
cd path/to/your/folder

# 2. Create and activate a virtual environment
python -m venv env

# On Windows:
env\Scripts\activate
# On Mac/Linux:
# source env/bin/activate

# 3. Install required dependencies
pip install numpy pandas scikit-learn matplotlib joblib lightgbm folium cartopy pyserial

# 4. Run the AI Pipeline sequentially
python generate_history.py   # Step A: Generate 90 days of synthetic history
python train_model.py        # Step B: Train the AI model
python sim_nodes.py          # Step C: Simulate satellite telemetry reception
python AI_Ground_System.py   # Step D: Run the main dashboard to visualize results
```
### Phase 2: Hardware Setup (Physical Deployment)
To flash the physical devices, ensure you have the **ESP32 Board Manager** installed in your Arduino IDE, along with the following libraries:
* `LoRa` (by Sandeep Mistry)
* `Adafruit BME280 Library` & `Adafruit MPU6050`
* `TinyGPSPlus`

**Flashing Instructions:**
1. Flash `gns_code.cpp` to the **ESP32-WROOM** boards.
2. Flash `satellite_codev5_master.cpp` to the **ESP32-S3**.
3. Flash `satellite_codev5_slave.cpp` to the **ESP32-CAM**.



---

## Hardware Reference: Pin Mapping

### 1. Ground Sensor Node (ESP32-WROOM)
| Component | Pin Name | GPIO | Note |
| :--- | :--- | :--- | :--- |
| **LoRa (SX1278)** | NSS (CS) / RST / DIO0 | 5 / 14 / 2 | SPI Bus |
| **Sensors (I2C)** | SDA / SCL | 42 / 41 | BME280 + MPU6050 |
| **Soil Sensor** | Signal | 34 | Analog Input Only |
| **GPS (NEO-M8N)** | TX / RX | 16 / 17 | Connect to GPS TX/RX |

### 2. CubeSat Master Node (ESP32-S3)
| Component | Pin Name | GPIO | Note |
| :--- | :--- | :--- | :--- |
| **LoRa (Ra-02)** | MISO / MOSI / SCK | 13 / 11 / 12 | SPI Bus |
| | NSS / RST / DIO0 | 10 / 5 / 6 | |
| **Sensors (I2C)** | SDA / SCL | 42 / 41 | BME280 + MPU6050 |
| **GPS (NEO-M8N)** | TX / RX | 18 / 17 | Connect to GPS TX/RX |
| **Slave Comm** | RX / TX | 16 / 15 | Connect to CAM U0T/U0R |

### 3. CubeSat Slave Node (ESP32-CAM)
| Pin Name | Connection | Description |
| :--- | :--- | :--- |
| **5V** | 5V Source | Requires stable >500mA source |
| **GND** | Common GND | **Must connect to Master GND** |
| **U0R** | Master TX (15) | Receive Commands |
| **U0T** | Master RX (16) | Transmit Image Data |

---

## Telemetry Data Formats

### 1. Ground Node Packet (Uplink)
* **Format:** `GN,[ID],[TYPE],[TEMP],[HUM],[PRES],[SOIL],[VIB],[LAT],[LON]`
* **Example:** `GN,12,LANDSLIDE,26.4,94.2,992.5,89.5,1.35,20.812350,105.331520`

### 2. Satellite Heartbeat (Downlink)
* **Format:** `TM:[VOLT],[LAT],[LON],[ALT],[STATUS] ; REL_GNS:[PIGGYBACKED_GROUND_DATA]`
* **Example:** `TM:4.15,21.033333,105.850000,505120.50,OK ; REL_GNS:GN,12,LANDSLIDE...`

### 3. AI Predictive Output (JSON)
Parsed output generated by the Random Forest Engine (`predict_inference.py`) for the dashboard.
```json
{
  "node_id": 101,
  "timestamp": "2026-02-14T12:00:00Z",
  "risk_analysis": {
    "probability_score": 88.5,
    "hazard_type": "LANDSLIDE"
  },
  "sensor_fusion": {
    "soil_saturation": 85.0,
    "ndvi_baseline": 0.21,
    "pressure_trend": -3.5
  }
}
